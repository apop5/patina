# RFC: `ESRT (EFI System Resource Table)`

This RFC proposes a Rust-based interface for managing the EFI System Resource Table (ESRT), safely
encapsulating the `ESRT_MANAGEMENT_PROTOCOL` functionality from the UEFI specification behind an
idiomatic Rust service. It introduces an `EsrtRecords` trait for registering, updating, removing,
and publishing ESRT entries that describe updatable firmware resources. The design focuses on:
(1) preserving required UEFI semantics, (2) reducing memory‑unsafe patterns inherent in the C
protocol, and (3) enforcing a minimal, future‑extensible surface for firmware update tracking.

## Change Log

- 2025-10-14: Initial RFC created.

## Motivation

The EFI System Resource Table (ESRT) provides a standardized mechanism for firmware to communicate
information about updatable system resources to the operating system. This includes system firmware,
device firmware, and UEFI drivers that can be updated through the UEFI UpdateCapsule mechanism. This
RFC proposes a pure Rust interface for existing ESRT capabilities, replacing the C-based implementations
while preserving the semantics and behavior specified in the UEFI specification.

**Compatibility Definition**:

1. **Functional Equivalence**: The Rust implementation provides all functionality required by `ESRT_MANAGEMENT_PROTOCOL`
2. **Semantic Preservation**: Operations maintain the same behavior, constraints, and error conditions as specified in UEFI
3. **Data Format Compliance**: ESRT table structures conform exactly to the UEFI specification
4. **Interface Transformation**: C-style function pointers, raw pointers, and u32 constants are replaced with idiomatic
   Rust traits, ownership, type safety, and strongly-typed enums
5. **Interoperability**: The implementation can produce C-compatible protocol bindings when needed for legacy component integration

This approach provides a simpler, safer Rust-based interface while maintaining required ESRT functionality and
ensuring that the resulting firmware behavior aligns with UEFI specification requirements. By using Rust-native
types (enums for firmware types and status codes, Guid instead of raw arrays), the API prevents entire classes
of errors at compile time that would be runtime errors in C.

### Scope

The `EsrtRecords` service implements equivalent functionality for the following protocol:

- `ESRT_MANAGEMENT_PROTOCOL`
  - `RegisterEsrtEntry`
  - `UpdateEsrtEntry`
  - `UnRegisterEsrtEntry`
  - `GetEsrtEntry`
  - `SyncEsrtFmp`
  - `LockEsrtRepository`

Additionally, the service provides ESRT table publication to the UEFI Configuration Table for OS visibility.

## Technology Background

The EFI System Resource Table (ESRT) provides a standardized mechanism for firmware to communicate
updatable resource information to the operating system. The ESRT contains entries describing firmware
resources (system firmware, device firmware, UEFI drivers) with version information, update status,
and rollback protection metadata. See UEFI Specification 2.11, Section 23.4 for complete details.

ESRT resources originate from two sources:

- **FMP (Firmware Management Protocol)**: Dynamic resources from FMP protocol instances
- **Non-FMP**: Static resources registered by platform code

The UEFI Forum Specifications define the ESRT Management Protocol for managing entries:
[ESRT_MANAGEMENT_PROTOCOL](https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Include/Protocol/EsrtManagement.h)

## Goals

Create an idiomatic Rust API for ESRT-related protocols (*see [Motivation - Scope](#scope)*).

## Requirements

1. The API should provide all necessary ESRT functionality as a service to components
2. The API should utilize Rust best practices, particularly memory safety and error handling
3. The ESRT service should produce protocols equivalent to the current C implementations, preserving existing C functionality
4. Support both FMP-based and Non-FMP resource registration
5. Provide automatic FMP synchronization to discover dynamic firmware resources
6. Enable repository locking to prevent modifications after platform initialization
7. Publish ESRT table to UEFI Configuration Table for OS consumption

## Unresolved Questions

None at this time.

## Prior Art (Existing PI C Implementation)

This Patina-based ESRT implementation follows the ESRT Management Protocol as implemented in EDK2.
In C, `ESRT_PRIVATE_DATA` provides the core management structure with separate locks for FMP and
Non-FMP repositories. Entries are stored in UEFI variables (`EsrtFmp` and `EsrtNonFmp`) and the
driver publishes the consolidated table to the Configuration Table on the Ready To Boot event.

Key C implementation patterns preserved:

- Separate variable storage for FMP and Non-FMP entries
- Lock-protected repository access
- Entry-level granularity for all operations
- Explicit FMP synchronization timing
- Ready To Boot event for table publication

### Dependencies on C Protocols

While the final outcome should be a purely Rust-based interface, the current implementation depends on:

- `FirmwareManagementProtocol` for FMP enumeration

Note: RuntimeServices and BootServices are natively provided by Patina and do not require C FFI.

## Alternatives

### Memory Safety Considerations

**Security-First Approach**: This implementation prioritizes memory safety and specification compliance.
All ESRT entry operations validate input data before modification to prevent corruption of the firmware
update metadata that the OS relies upon.

#### Entry Validation Safety Model

The service validates all ESRT entries before accepting them into the repository:

1. **FwClass Uniqueness**: Prevents duplicate GUIDs within the same repository (FMP or Non-FMP)
2. **Firmware Type Validation**: Ensures FwType is one of the valid values (System/Device/Driver)
3. **Version Consistency**: Validates that FwVersion >= LowestSupportedFwVersion
4. **Repository Capacity**: Enforces maximum entry limits to prevent unbounded growth

### Alternative Design Choices

The design prioritizes memory safety through:

- **Entry Validation**: FwClass uniqueness, firmware type validation, version consistency checks, capacity limits
- **Repository Separation**: Separate FMP/Non-FMP storage preserves trust boundaries and lifecycle management
- **Write Protection**: `lock_repository()` prevents post-initialization modifications

### Rejected Alternatives

**Single Unified Repository**: Rejected because it loses the trust boundary between platform and third-party code,
complicates synchronization, and creates a single point of failure.

**Automatic FMP Synchronization**: Rejected to give platforms explicit control over enumeration timing and avoid
complexity of event-based synchronization.

**In-Memory Storage**: Rejected because `LastAttemptVersion`/`LastAttemptStatus` must persist across reboots
per UEFI specification requirements.

**Bulk Entry Operations**: Rejected due to complexity in partial failure handling and atomicity. Entry-level
operations match UEFI semantics and can be wrapped if needed.

## Rust Code Design

### Component Architecture

The ESRT service follows Patina's component/service pattern:

```rust
#[derive(IntoComponent, IntoService)]
#[service(dyn EsrtRecords)]
pub struct EsrtManager {
    // Internal state for entry management
}
```

The service is registered using the Commands pattern in the component entry point. During initialization,
the component registers a Ready To Boot event handler to automatically publish the ESRT table:

```rust
fn entry_point(
    mut self,
    config: Option<Config<EsrtConfiguration>>,
    mut commands: Commands,
    boot_services: Service<dyn BootServices>,
) -> Result<()> {
    // Initialize repositories with configured capacities
    
    // Register Ready To Boot event handler to publish ESRT table
    boot_services.create_event_ex(
        EventType::NOTIFY_SIGNAL,
        Tpl::CALLBACK,
        Some(ready_to_boot_callback),
        event_context,
        &EVENT_GROUP_READY_TO_BOOT,
    )?;
    
    commands.add_service(self);
    Ok(())
}
```

Platforms can configure ESRT capacity limits:

```rust
pub struct EsrtConfiguration {
    pub max_fmp_entries: u32,     // Defaults to platform-specific value
    pub max_non_fmp_entries: u32, // Defaults to platform-specific value
}
```

### Service Overview

The ESRT component exposes one primary capability: a resource entry service that collects firmware
resource metadata, stores it persistently, and (on demand) publishes a consolidated ESRT table to
the UEFI Configuration Table.

Key responsibilities:

- **Entry Registration**: Accept Non-FMP entries from platform code with validation
- **Entry Updates**: Modify existing entries (typically LastAttemptVersion/Status after updates)
- **Entry Removal**: Remove Non-FMP entries that are no longer applicable
- **FMP Synchronization**: Enumerate FMP instances and update FMP repository
- **Repository Locking**: Prevent modifications after platform initialization
- **Automatic Table Publication**: Register Ready To Boot event handler to publish consolidated ESRT

### Public Interaction Pattern (High Level)

1. Platform code registers Non-FMP entries for system firmware resources
2. After device enumeration, platform calls `sync_fmp()` to discover FMP resources
3. Platform may update entries to reflect firmware update attempts
4. Before End of DXE, platform calls `lock_repository()`
5. On Ready To Boot event, service automatically publishes consolidated ESRT table
6. OS reads ESRT from Configuration Table to determine updatable resources

Error surfaces (design‑relevant):

- Duplicate FwClass GUID in registration
- Repository full (capacity exhausted)
- Entry not found on update/unregister
- Repository locked (write-protected)
- FMP synchronization failures

### Safety Boundary

The service uses Rust-native types with strong typing and validation. ESRT entries are represented
as Rust structs with enforced invariants, eliminating memory-unsafe patterns from C-style raw data
manipulation. Type-safe enums represent firmware types and status codes, preventing invalid values
at compile time.

## Guide-Level Explanation

Platform components receive the ESRT service as a parameter and use it to manage firmware resource
metadata throughout the boot process. The ESRT table is automatically published on the Ready To Boot
event - platforms do not need to call `publish_table()` explicitly.

```rust
use patina::component::service::Service;

fn platform_init(esrt: Service<dyn EsrtRecords>) -> Result<()> {
    // Register system firmware resource
    let system_fw = SystemResourceEntry {
        fw_class: SYSTEM_FIRMWARE_GUID,
        fw_type: FirmwareType::SystemFirmware,
        fw_version: 0x00010002,
        lowest_supported_fw_version: 0x00010000,
        capsule_flags: CAPSULE_FLAGS_PERSIST_ACROSS_RESET,
        last_attempt_version: 0,
        last_attempt_status: LastAttemptStatus::Success,
    };
    esrt.register_entry(&system_fw)?;

    // After device enumeration, sync FMP resources
    esrt.sync_fmp()?;

    // Update entry after firmware update attempt
    let mut entry = esrt.get_entry(&SYSTEM_FIRMWARE_GUID)?;
    entry.last_attempt_version = new_version;
    entry.last_attempt_status = LastAttemptStatus::Success;
    esrt.update_entry(&entry)?;

    // Lock before OS handoff
    esrt.lock_repository()?;
    
    // Table will be automatically published on Ready To Boot event

    Ok(())
}
```

## Appendix A: Public API Summary

This appendix lists only the externally visible, intentionally supported surface. Internal helper types
(variable storage, repository structures, FFI glue) are intentionally excluded.

### Configuration

```rust
pub struct EsrtConfiguration {
    pub max_fmp_entries: u32,     // Maximum FMP entries, default platform-specific
    pub max_non_fmp_entries: u32, // Maximum Non-FMP entries, default platform-specific
}
```

### Core Types

```rust
/// Firmware resource entry
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SystemResourceEntry {
    pub fw_class: Guid,
    pub fw_type: FirmwareType,
    pub fw_version: u32,
    pub lowest_supported_fw_version: u32,
    pub capsule_flags: u32,
    pub last_attempt_version: u32,
    pub last_attempt_status: LastAttemptStatus,
}

/// Firmware type classification
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FirmwareType {
    Unknown,
    SystemFirmware,
    DeviceFirmware,
    UefiDriver,
}

/// Last update attempt status
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LastAttemptStatus {
    Success,
    ErrorUnsuccessful,
    ErrorInsufficientResources,
    ErrorIncorrectVersion,
    ErrorInvalidFormat,
    ErrorAuthError,
    ErrorPowerEventAc,
    ErrorPowerEventBattery,
    ErrorUnsatisfiedDependencies,
    // Additional status codes per UEFI spec
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EsrtError {
    InvalidParameter,
    NotFound,
    AlreadyExists,
    OutOfResources,
    WriteProtected,
    RepositoryCorrupt,
}
```

### Service Trait (Stable Surface)

```rust
pub trait EsrtRecords {
    /// Register a Non-FMP entry (platform-provided firmware resource)
    fn register_entry(&self, entry: &SystemResourceEntry) -> Result<(), EsrtError>;
    
    /// Update an existing entry (FMP or Non-FMP)
    fn update_entry(&self, entry: &SystemResourceEntry) -> Result<(), EsrtError>;
    
    /// Unregister a Non-FMP entry
    fn unregister_entry(&self, fw_class: &Guid) -> Result<(), EsrtError>;
    
    /// Retrieve an entry by FwClass GUID
    fn get_entry(&self, fw_class: &Guid) -> Result<SystemResourceEntry, EsrtError>;
    
    /// Synchronize FMP repository with installed FMP protocol instances
    fn sync_fmp(&self) -> Result<(), EsrtError>;
    
    /// Lock both repositories to prevent further modifications
    fn lock_repository(&self) -> Result<(), EsrtError>;
}
```

Notes:

- `register_entry` and `unregister_entry` only work with Non-FMP entries
- `update_entry` and `get_entry` work with both FMP and Non-FMP entries
- All operations return `EsrtError::WriteProtected` if called after `lock_repository()`
- ESRT table automatically published to Configuration Table on Ready To Boot event
- Table published using ESRT GUID (B122A263-3661-4F68-9929-78F8B0D62180)
- `SystemResourceEntry` converted to C-compatible `EFI_SYSTEM_RESOURCE_ENTRY` format internally
- Component registers Ready To Boot event handler during initialization using `boot_services.create_event_ex()`

## Appendix B: UEFI Specification Reference

The ESRT is defined in the UEFI Specification:

- **UEFI Specification 2.11**, Section 23.4 - EFI System Resource Table

Key specification requirements:

- ESRT must be published to Configuration Table before OS handoff
- Each entry's FwClass GUID must be unique within the table
- FwResourceVersion must be set to 1 (current specification version)
- LastAttemptStatus must persist across reboots
- Table memory should be allocated as ACPI Reclaim or Runtime Services data
